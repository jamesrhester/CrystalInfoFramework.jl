var documenterSearchIndex = {"docs":
[{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/#CIF-files","page":"API","title":"CIF files","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Cif is a collection of CifContainers indexed by a String label.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Cif(s::AbstractString;verbose=false)\nkeys(c::Cif)\nfirst(c::Cif)\nlength(c::Cif)\nhaskey(c::Cif,name)\ngetindex(c::Cif,n)\nsetindex!(c::Cif,v,n)\nshow(io::IO,::MIME\"text/plain\",c::Cif)","category":"page"},{"location":"api/#CrystalInfoFramework.Cif-Tuple{AbstractString}","page":"API","title":"CrystalInfoFramework.Cif","text":"Cif(s::AbstractString;verbose=false)\n\nRead in filename s as a CIF file. If verbose is true, print progress information during parsing.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.keys-Tuple{Cif}","page":"API","title":"Base.keys","text":"keys(c::Cif)\n\nThe names of all blocks in c, not including any save frames.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.first-Tuple{Cif}","page":"API","title":"Base.first","text":"first(c::Cif)\n\nThe first block in c, which may not be the first block that appears in the physical file.  This is useful when only one block is present.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Cif}","page":"API","title":"Base.length","text":"length(c::Cif)\n\nThe number of blocks in n.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{Cif,Any}","page":"API","title":"Base.haskey","text":"haskey(c::Cif,name)\n\nWhether c has a block named name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Cif,Any}","page":"API","title":"Base.getindex","text":"getindex(c::Cif,n)\n\nc[n] returns the block named n in c.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{Cif,Any,Any}","page":"API","title":"Base.setindex!","text":"setindex!(c::Cif,v,n)\n\nc[n] = s sets block n to v in c.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO,MIME{Symbol(\"text/plain\")},Cif}","page":"API","title":"Base.show","text":"show(io::IO,::MIME\"text/plain\",c::Cif)\n\nDisplay a text representation of c to io. This text representation is not guaranteed to be syntactically correct CIF. To display c as a CIF file, use ::MIME\"text/cif\".\n\n\n\n\n\n","category":"method"},{"location":"api/#CIF-blocks","page":"API","title":"CIF blocks","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Concrete types of CifContainers are Block and CifBlock. Only the latter may contain nested save frames.  CifContainers act like Dict{String,Array{CifValue,1}}  dictionaries indexed by data name.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Block\nCifBlock\nkeys(b::CifContainer)\nhaskey(b::CifContainer,s::String)\niterate(b::CifContainer)\ngetindex(b::CifContainer,s::String)\nget(b::CifContainer,s::String,a)\ngetindex(b::CifContainer,s::Dict)\nsetindex!(b::CifContainer,v,s)\ndelete!(b::CifContainer,s)","category":"page"},{"location":"api/#CrystalInfoFramework.Block","page":"API","title":"CrystalInfoFramework.Block","text":"A CIF data block or save frame containing no nested save frames.\n\n\n\n\n\n","category":"type"},{"location":"api/#CrystalInfoFramework.CifBlock","page":"API","title":"CrystalInfoFramework.CifBlock","text":"A CIF block potentially containing save frames.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.keys-Tuple{CifContainer}","page":"API","title":"Base.keys","text":"keys(b::CifContainer)\n\nAll data names in b\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{CifContainer,String}","page":"API","title":"Base.haskey","text":"haskey(b::CifContainer,s::String)\n\nReturns true if b contains a value for case-insensitive data name s\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Tuple{CifContainer}","page":"API","title":"Base.iterate","text":"iterate(b::CifContainer)\n\nIterate over all data names in b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{CifContainer,String}","page":"API","title":"Base.getindex","text":"getindex(b::CifContainer,s::String)\n\nb[s] returns all values for case-insensitive data name s in  b as an Array{CifValue,1}\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.get-Tuple{CifContainer,String,Any}","page":"API","title":"Base.get","text":"get(b::CifContainer,s::String,a)\n\nReturn b[s]. If s is missing, return a. s is case-insensitive.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{CifContainer,Dict}","page":"API","title":"Base.getindex","text":"getindex(b::CifContainer,s::Dict)\n\nReturn the set of values in b corresponding to the data name values provided in s. The keys of s must be datanames found in b. A DataFrame is returned. The keys of s are case-insensitive.  \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{CifContainer,Any,Any}","page":"API","title":"Base.setindex!","text":"setindex!(b::CifContainer,v,s)\n\nSet the value of s in b to v\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.delete!-Tuple{CifContainer,Any}","page":"API","title":"Base.delete!","text":"delete!(b::CifContainer,s)\n\nRemove the value of s from b\n\n\n\n\n\n","category":"method"},{"location":"api/#CIF-values","page":"API","title":"CIF values","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Data names are associated with arrays of values of type CifValue.  Single-valued data names are associated with arrays with a single element.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CifValue","category":"page"},{"location":"api/#CrystalInfoFramework.CifValue","page":"API","title":"CrystalInfoFramework.CifValue","text":"The syntactical type of data held in a CIF file. A value is of type String, Vector{CifValue}, Dict{String,CifValue}, Missing or Nothing. In all cases the values returned for a given data name are in an  Array{CifValue,1}. \n\n\n\n\n\n","category":"type"},{"location":"api/#Loops","page":"API","title":"Loops","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CIF blocks contain key-value pairs and loops. The following methods give access to these loops.","category":"page"},{"location":"api/","page":"API","title":"API","text":"get_loop\nadd_to_loop!\ncreate_loop!","category":"page"},{"location":"api/#CrystalInfoFramework.get_loop","page":"API","title":"CrystalInfoFramework.get_loop","text":"get_loop(b::CifContainer,s)\n\nA DataFrame built from data items in the same loop as s. If no data are available, an empty DataFrame is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#CrystalInfoFramework.add_to_loop!","page":"API","title":"CrystalInfoFramework.add_to_loop!","text":"add_to_loop!(b::CifContainer, tgt, newname)\n\nAdd dataname tgt to the loop containing newname. Values for tgt must already be present (e.g. by calling b[tgt]=values) and have the same length as other  values in the loop.\n\n\n\n\n\n","category":"function"},{"location":"api/#CrystalInfoFramework.create_loop!","page":"API","title":"CrystalInfoFramework.create_loop!","text":"create_loop!(b::CifContainer,names::Array{String,1})\n\nCreate a loop in b from the datanames in names.  Datanames  previously assigned to other loops are transferred to the new loop. All data attached to names  should have the same length.\n\n\n\n\n\n","category":"function"},{"location":"api/#Save-frames","page":"API","title":"Save frames","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CIF data files do not contain save frames, however CIF dictionaries use them extensively.  The contents of save frames are invisible to all methods except show. They can be accessed using get_frames, which returns a Cif object.","category":"page"},{"location":"api/","page":"API","title":"API","text":"get_frames(f::CifBlock{V}) where V","category":"page"},{"location":"api/#CrystalInfoFramework.get_frames-Union{Tuple{CifBlock{V}}, Tuple{V}} where V","page":"API","title":"CrystalInfoFramework.get_frames","text":"get_frames(f::CifBlock{V})\n\nReturn all nested CIF containers in f as a Cif object.\n\n\n\n\n\n","category":"method"},{"location":"#CrystalInfoFramework.jl","page":"Overview","title":"CrystalInfoFramework.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This module implements the International Union of Crystallography's  Crystallographic Information Framework (CIF) standard for CIF file syntax and CIF dictionary construction.","category":"page"},{"location":"tutorial/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"The CIF files used in these examples are provided in the docs directory.","category":"page"},{"location":"tutorial/#Reading-a-CIF-file","page":"Guide","title":"Reading a CIF file","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"To open CIF file demo.cif, and read _cell.length_a from block saly2_all_aniso:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"\nusing CrystalInfoFramework\n\nnc = Cif(\"demo.cif\")\nmy_block = nc[\"saly2_all_aniso\"]  #could also use first(nc).second\nmy_block[\"_cell.length_a\"]\n\n# output\n\n1-element Array{Union{Missing, Nothing, Dict{String,T}, Array{T,1}, String} where T,1}:\n \"11.520(12)\"","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Note that values are always returned as Array type, with the value for a key value pair being a single-element array. The values in the arrays returned are either String, Missing (CIF ?), Nothing (CIF .) or compound types Dict and Array which are only available for CIF2 syntax files.","category":"page"},{"location":"tutorial/#Loops","page":"Guide","title":"Loops","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Individual columns are returned when the data name is requested, as above.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"get_loop returns a DataFrame object that can be manipulated using the  methods of that package, most obviously, eachrow to iterate over the packets in a loop. To specify the required loop, simply provide any  data name that appears in the loop.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"\nl = get_loop(my_block,\"_atom_site.label\");\n\nfor r in eachrow(l)\n    println(\"$(r[Symbol(\"_atom_site.fract_x\")])\")\nend\n\n# output\n\n.5505(5)\n.4009(5)\n.2501(5)\n.4170(7)\n.3145(7)\n.2789(8)\n.3417(9)\n.4445(9)\n.4797(8)\n.4549(7)","category":"page"},{"location":"tutorial/#Updating-a-CIF-file","page":"Guide","title":"Updating a CIF file","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Single key-value pairs are added in the same way as for a normal dictionary. ","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"my_block[\"_new_item\"] = \"a fine item\"\nmy_block[\"_number_item\"] = 23","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If the dataname belongs to a loop, a two-step process is required to add the values. First the column of values for the new data name is added as above, and then the new dataname can be added to a previously-existing  loop. The following call adds _new_loop_item to the loop containing  _old_item:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"my_block[\"_new_loop_item\"] = [1,2,3,4]\nadd_to_loop!(my_block,\"_old_item\",\"_new_loop_item\")","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"The number of values in the array assigned to _new_loop_item must match the length of the loop it is added to - this is checked.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A completely new loop can be created with create_loop!.  The columns corresponding to the data names provided to create_loop must  have previously been added to the data block, just like for add_to_loop!.","category":"page"},{"location":"tutorial/#Writing-CIFs","page":"Guide","title":"Writing CIFs","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"To write a CIF, open an IO stream and write the contents of the Cif object as MIME type \"text/cif\":","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"t = open(\"newcif.cif\",\"w\")\nshow(t,MIME(\"text/cif\"),mycif)\nclose(t)","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Note that currently no checks are made for correct construction of data names (e.g. leading underscore and characterset restrictions). This will be checked in the future.","category":"page"},{"location":"tutorial/#Dictionaries-and-DataSources","page":"Guide","title":"Dictionaries and DataSources","text":"","category":"section"},{"location":"tutorial/#Dictionaries","page":"Guide","title":"Dictionaries","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"CIF dictionaries are created by passing the dictionary file name to DDLm_Dictionary or DDL2_Dictionary constructors.  Note that DDL2 dictionaries are published by the Protein Data Bank (wwPDB) and DDLm dictionaries are used by the IUCr.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"d = DDLm_Dictionary(\"cif_core.dic\")","category":"page"},{"location":"tutorial/#DataSources","page":"Guide","title":"DataSources","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"CIF dictionaries can be used with any DataSource, providing that that datasource recognises the data names defined in the dictionary.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A DataSource is any data source returning an array of values when supplied with a string.  A CIF Block conforms to this specification, as does a simple Dict{String,Any}.  DataSources  are defined in submodule CrystalInfoFramework.DataContainer.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A CIF dictionary can be used to obtain data with correct Julia type from a DataSource that uses data names defined in the dictionary by  creating a TypedDataSource:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"using CrystalInfoFramework.DataContainer\nmy_dict = DDLm_Dictionary(\"../test/cif_core.dic\")\nbd = TypedDataSource(my_block,my_dict)\nbd[\"_cell.length_a\"]\n\n# output\n\n1-element Array{Float64,1}:\n 11.52\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Note that the array elements are now Float64 and that the standard uncertainty has been removed. Future improvements may use Measurements.jl to retain standard uncertainties.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Dictionaries also allow alternative names for a data name to be recognised provided these are noted in the dictionary:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"\nl = bd[\"_cell_length_a\"] #no period in name\n\n# output\n\n1-element Array{Float64,1}:\n 11.52\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"where _cell_length_a is the old form of the data name.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Currently transformations from DataSource values to Julia values assume that the DataSource values are Strings that can be directly parsed by the Julia parse method. In the future this will become a DataSource-specific operation to allow binary formats to be handled.","category":"page"},{"location":"tutorial/#Creating-new-DataSources","page":"Guide","title":"Creating new DataSources","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A file format can be used with CIF dictionaries if:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"It returns an Array of values when provided with a data name defined","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"in the dictionary","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Arrays returned for data names from the same CIF category have","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"corresponding values at the same position in the array - that is, they line up correctly if presented as columns in a table.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"At a minimum, the following methods should work with the DataSource:  getindex, haskey.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If the DataSource mds can be modelled as a collection of DataSources, iterate_blocks should also be defined to iterate over the constituent DataSources. MultiDataSource(mds) will then create a DataSource where values returned for any data names defined in the constituent blocks are automatically aligned. Such MultiDataSource objects can be built to form hierarchies.","category":"page"},{"location":"tutorial/#Types","page":"Guide","title":"Types","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A TypedDataSource consists of a DataSource and a CIF dictionary. Values returned from a TypedDataSource are in the appropriate Julia type as specified by the dictionary. Where a DataSource returns pure text, that text is converted to the appropriate type using Julia's parse.  ","category":"page"}]
}
