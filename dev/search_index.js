var documenterSearchIndex = {"docs":
[{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/#CIF-files","page":"API","title":"CIF files","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A Cif is a collection of CifContainers indexed by a String label.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Cif(s::AbstractPath;verbose=false,native=false,version=0)\nCif(s::AbstractString;verbose=false,version=0,source=p\"\")\nkeys(c::Cif)\nfirst(c::Cif)\nlength(c::Cif)\nhaskey(c::Cif,name)\ngetindex(c::Cif,n)\nsetindex!(c::Cif,v,n)\nshow(io::IO,::MIME\"text/plain\",c::Cif)","category":"page"},{"location":"api/#CrystalInfoFramework.Cif-Tuple{AbstractPath}","page":"API","title":"CrystalInfoFramework.Cif","text":"Cif(s::AbstractPath;verbose=false,native=false,version=0)\n\nRead in filename s as a CIF file. If verbose is true, print progress information during parsing. If native is false, use the C-language parser provided by libcif.  If libcif is not available, the native Julia parser will be used. version may be 1, 2 or 0 (default) for auto-detected CIF version. version is only respected by the native parser. The libcif parser will always auto-detect.  \n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.Cif-Tuple{AbstractString}","page":"API","title":"CrystalInfoFramework.Cif","text":"Cif(s::AbstractString;verbose=false,version=0,source=p\"\")\n\nProcess contents of s as a CIF file using the native Julia parser. If verbose is true, print progress information during parsing. version may be 1, 2 or 0 (default) for auto-detected CIF version. If source is provided, it is a filesystem location to record as the source for s.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.keys-Tuple{Cif}","page":"API","title":"Base.keys","text":"keys(c::Cif)\n\nThe names of all blocks in c, not including any save frames.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.first-Tuple{Cif}","page":"API","title":"Base.first","text":"first(c::Cif)\n\nThe first block in c, which may not be the first block that appears in the physical file.  This is useful when only one block is present.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{Cif}","page":"API","title":"Base.length","text":"length(c::Cif)\n\nThe number of blocks in n.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{Cif, Any}","page":"API","title":"Base.haskey","text":"haskey(c::Cif,name)\n\nWhether c has a block named name.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Cif, Any}","page":"API","title":"Base.getindex","text":"getindex(c::Cif,n)\n\nc[n] returns the block named n in c.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{Cif, Any, Any}","page":"API","title":"Base.setindex!","text":"setindex!(c::Cif,v,n)\n\nc[n] = s sets block n to v in c.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, Cif}","page":"API","title":"Base.show","text":"show(io::IO,::MIME\"text/plain\",c::Cif)\n\nDisplay a text representation of c to io. This text representation is not guaranteed to be syntactically correct CIF. To display c as a CIF file, use ::MIME\"text/cif\".\n\n\n\n\n\n","category":"method"},{"location":"api/#CIF-blocks","page":"API","title":"CIF blocks","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Concrete types of CifContainers are Block and CifBlock. Only the latter may contain nested save frames.  CifContainers act like Dict{String,Array{CifValue,1}}  dictionaries indexed by data name.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Block\nCifBlock\nkeys(b::CifContainer)\nhaskey(b::CifContainer,s::String)\niterate(b::CifContainer)\ngetindex(b::CifContainer,s::String)\nget(b::CifContainer,s::String,a)\ngetindex(b::CifContainer,s::Dict)\nsetindex!(b::CifContainer,v,s)\ndelete!(b::CifContainer,s)","category":"page"},{"location":"api/#CrystalInfoFramework.Block","page":"API","title":"CrystalInfoFramework.Block","text":"A CIF data block or save frame containing no nested save frames.\n\n\n\n\n\n","category":"type"},{"location":"api/#CrystalInfoFramework.CifBlock","page":"API","title":"CrystalInfoFramework.CifBlock","text":"A CIF block potentially containing save frames. Save frames cannot be nested.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.keys-Tuple{CifContainer}","page":"API","title":"Base.keys","text":"keys(b::CifContainer)\n\nAll data names in b\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{CifContainer, String}","page":"API","title":"Base.haskey","text":"haskey(b::CifContainer,s::String)\n\nReturns true if b contains a value for case-insensitive data name s\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate-Tuple{CifContainer}","page":"API","title":"Base.iterate","text":"iterate(b::CifContainer)\n\nIterate over all data names in b.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{CifContainer, String}","page":"API","title":"Base.getindex","text":"getindex(b::CifContainer,s::String)\n\nb[s] returns all values for case-insensitive data name s in  b as an Array{CifValue,1}\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.get-Tuple{CifContainer, String, Any}","page":"API","title":"Base.get","text":"get(b::CifContainer,s::String,a)\n\nReturn b[s]. If s is missing, return a. s is case-insensitive.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{CifContainer, Dict}","page":"API","title":"Base.getindex","text":"getindex(b::CifContainer,s::Dict)\n\nReturn the set of values in b corresponding to the data name values provided in s. The keys of s must be datanames found in b. A DataFrame is returned. The keys of s are case-insensitive.  \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{CifContainer, Any, Any}","page":"API","title":"Base.setindex!","text":"setindex!(b::CifContainer,v,s)\n\nSet the value of s in b to v\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.delete!-Tuple{CifContainer, Any}","page":"API","title":"Base.delete!","text":"delete!(b::CifContainer,s)\n\nRemove the value of s from b\n\n\n\n\n\n","category":"method"},{"location":"api/#CIF-values","page":"API","title":"CIF values","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Data names are associated with arrays of values of type CifValue.  Single-valued data names are associated with arrays with a single element.","category":"page"},{"location":"api/","page":"API","title":"API","text":"CifValue","category":"page"},{"location":"api/#CrystalInfoFramework.CifValue","page":"API","title":"CrystalInfoFramework.CifValue","text":"The syntactical type of data held in a CIF file. A value is of type String, Vector{CifValue}, Dict{String,CifValue}, Missing or Nothing. In all cases the values returned for a given data name are in an  Array{CifValue,1}. \n\n\n\n\n\n","category":"type"},{"location":"api/#Loops","page":"API","title":"Loops","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CIF blocks contain key-value pairs and loops. The following methods give access to these loops.","category":"page"},{"location":"api/","page":"API","title":"API","text":"get_loop\nadd_to_loop!\ncreate_loop!","category":"page"},{"location":"api/#CrystalInfoFramework.get_loop","page":"API","title":"CrystalInfoFramework.get_loop","text":"get_loop(b::CifContainer,s)\n\nA DataFrame built from data items in the same loop as s. If no data are available, an empty DataFrame is returned.\n\n\n\n\n\n","category":"function"},{"location":"api/#CrystalInfoFramework.add_to_loop!","page":"API","title":"CrystalInfoFramework.add_to_loop!","text":"add_to_loop!(b::CifContainer, tgt, newname)\n\nAdd dataname tgt to the loop containing newname. Values for tgt must already be present (e.g. by calling b[tgt]=values) and have the same length as other  values in the loop.\n\n\n\n\n\n","category":"function"},{"location":"api/#CrystalInfoFramework.create_loop!","page":"API","title":"CrystalInfoFramework.create_loop!","text":"create_loop!(b::CifContainer,names)\n\nCreate a loop in b from the datanames in names.  Datanames  previously assigned to other loops are transferred to the new loop. All data attached to names  should have the same length.\n\n\n\n\n\n","category":"function"},{"location":"api/#Save-frames","page":"API","title":"Save frames","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CIF data files do not contain save frames, however CIF dictionaries use them extensively.  The contents of save frames are invisible to all methods except show. They can be accessed using get_frames, which returns a Cif object.","category":"page"},{"location":"api/","page":"API","title":"API","text":"get_frames(f::CifBlock{V}) where V","category":"page"},{"location":"api/#CrystalInfoFramework.get_frames-Union{Tuple{CifBlock{V}}, Tuple{V}} where V","page":"API","title":"CrystalInfoFramework.get_frames","text":"get_frames(f::CifBlock{V})\n\nReturn all nested CIF containers in f as a Cif object.\n\n\n\n\n\n","category":"method"},{"location":"api/#CIF-dictionaries","page":"API","title":"CIF dictionaries","text":"","category":"section"},{"location":"api/#DDLm-Dictionaries","page":"API","title":"DDLm Dictionaries","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Dictionaries published by the International Union of Crystallography use the DDLm attribute set.","category":"page"},{"location":"api/","page":"API","title":"API","text":"DDLm_Dictionary\nDDLm_Dictionary(c::Cif;ignore_imports=false)\nDDLm_Dictionary(a::AbstractPath;verbose=false,ignore_imports=false)\nkeys(d::DDLm_Dictionary)\ngetindex(d::DDLm_Dictionary,k)\ndelete!(d::DDLm_Dictionary,k::String)\nget_dic_namespace(d::DDLm_Dictionary)\nlist_aliases(d::DDLm_Dictionary,name;include_self=false)\nfind_name(d::DDLm_Dictionary,name)\nfind_category(d::DDLm_Dictionary,dataname)\nfind_object(d::DDLm_Dictionary,dataname)\nis_category(d::DDLm_Dictionary,name)\nget_categories(d::DDLm_Dictionary)\nget_keys_for_cat(d::DDLm_Dictionary,cat;aliases=false)\nget_default(d::DDLm_Dictionary,s)\nlookup_default(dict::DDLm_Dictionary,dataname::String,cp)\nshow(io::IO,::MIME\"text/cif\",ddlm_dic::DDLm_Dictionary)","category":"page"},{"location":"api/#CrystalInfoFramework.DDLm_Dictionary","page":"API","title":"CrystalInfoFramework.DDLm_Dictionary","text":"A DDLm Dictionary holds information about data names including executable methods for deriving missing values.\n\n\n\n\n\n","category":"type"},{"location":"api/#CrystalInfoFramework.DDLm_Dictionary-Tuple{Cif}","page":"API","title":"CrystalInfoFramework.DDLm_Dictionary","text":"DDLm_Dictionary(c::Cif;ignore_imports=false)\n\nCreate a DDLm_Dictionary from c. ignore_imports = true will ignore any import attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.DDLm_Dictionary-Tuple{AbstractPath}","page":"API","title":"CrystalInfoFramework.DDLm_Dictionary","text":"DDLm_Dictionary(a::AbstractPath;verbose=false,ignore_imports=false)\n\nCreate a DDLm_Dictionary given filename a. verbose = true will print extra debugging information during reading.ignore_imports = true will ignore any import attributes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.keys-Tuple{DDLm_Dictionary}","page":"API","title":"Base.keys","text":"keys(d::DDLm_Dictionary)\n\nReturn a list of datanames defined by the dictionary, including any aliases.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{DDLm_Dictionary, Any}","page":"API","title":"Base.getindex","text":"getindex(d::DDLm_Dictionary,k)\n\nd[k] returns the  definition for data name k as a Dict{Symbol,DataFrame} where Symbol is the attribute category (e.g. :name).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.delete!-Tuple{DDLm_Dictionary, String}","page":"API","title":"Base.delete!","text":"delete!(d::DDLm_Dictionary,k::String)\n\nRemove all information from d associated with dataname k\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.get_dic_namespace-Tuple{DDLm_Dictionary}","page":"API","title":"CrystalInfoFramework.get_dic_namespace","text":"get_dic_namespace(d::DDLm_Dictionary)\n\nReturn the namespace declared by the dictionary, or ddlm if none present.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.list_aliases-Tuple{DDLm_Dictionary, Any}","page":"API","title":"CrystalInfoFramework.list_aliases","text":"list_aliases(d::DDLm_Dictionary,name;include_self=false)\n\nList aliases of name listed in d. If not include_self, remove name from the returned list.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.find_name-Tuple{DDLm_Dictionary, Any}","page":"API","title":"CrystalInfoFramework.find_name","text":"find_name(d::DDLm_Dictionary,name)\n\nFind the canonical name for name in d. If name is not present, return name unchanged. If accessed in cat/obj format, search also child categories. Note that the head category may not have a category associated with it. If name is the dictionary title it is returned as is.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.find_category-Tuple{DDLm_Dictionary, Any}","page":"API","title":"CrystalInfoFramework.find_category","text":"find_category(d::DDLm_Dictionary,dataname)\n\nFind the category of dataname by looking up d.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.find_object-Tuple{DDLm_Dictionary, Any}","page":"API","title":"CrystalInfoFramework.find_object","text":"find_object(d::DDLm_Dictionary,dataname)\n\nFind the object_id of dataname by looking up d.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.is_category-Tuple{DDLm_Dictionary, Any}","page":"API","title":"CrystalInfoFramework.is_category","text":"is_category(d::DDLm_Dictionary,name)\n\nReturn true if name is a category according to d.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.get_categories-Tuple{DDLm_Dictionary}","page":"API","title":"CrystalInfoFramework.get_categories","text":"get_categories(d::DDLm_Dictionary)\n\nList all categories defined in DDLm Dictionary d\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.get_keys_for_cat-Tuple{DDLm_Dictionary, Any}","page":"API","title":"CrystalInfoFramework.get_keys_for_cat","text":"get_keys_for_cat(d::DDLm_Dictionary,cat;aliases=false)\n\nList all category key data names for cat listed in d. If aliases, include alternative names for the key data names.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.get_default-Tuple{DDLm_Dictionary, Any}","page":"API","title":"CrystalInfoFramework.get_default","text":"get_default(d::DDLm_Dictionary,s)\n\nReturn the default value for s or missing if none defined. \n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.lookup_default-Tuple{DDLm_Dictionary, String, Any}","page":"API","title":"CrystalInfoFramework.lookup_default","text":"lookup_default(dict::DDLm_Dictionary,dataname::String,cp)\n\nIndex into any default lookup table defined in dict for dataname using an index value from cp. cp is any object with a property name as specified by def_index_id in the definition of  dataname such that cp.<def_index_id> returns a single value\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, MIME{Symbol(\"text/cif\")}, DDLm_Dictionary}","page":"API","title":"Base.show","text":"show(io::IO,MIME(text/cif),ddlm_dic::DDLm_Dictionary;header=\"\")\n\nOutput ddlm_dic in CIF format. header can contain text that will be output in a comment box at the top of the file. Lines may be no longer than 74 characters. Multiple lines are will be separated by spaces.\n\n\n\n\n\n","category":"method"},{"location":"api/#DDL2-Dictionaries","page":"API","title":"DDL2 Dictionaries","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DDL2 dictionaries are published and maintained by the worldwide Protein Data Bank (wwPDB).","category":"page"},{"location":"api/","page":"API","title":"API","text":"DDL2_Dictionary\nDDL2_Dictionary(c::Cif)\nDDL2_Dictionary(a::AbstractPath;verbose=false)\nkeys(d::DDL2_Dictionary)\ngetindex(d::DDL2_Dictionary,k)\nget_categories(d::DDL2_Dictionary)\nget_default(d::DDL2_Dictionary,dataname)\nshow(io::IO,::MIME\"text/cif\",ddl2_dic::DDL2_Dictionary)","category":"page"},{"location":"api/#CrystalInfoFramework.DDL2_Dictionary","page":"API","title":"CrystalInfoFramework.DDL2_Dictionary","text":"DDL2_Dictionary\n\nThe type of DDL2 dictionaries.\n\n\n\n\n\n","category":"type"},{"location":"api/#CrystalInfoFramework.DDL2_Dictionary-Tuple{Cif}","page":"API","title":"CrystalInfoFramework.DDL2_Dictionary","text":"DDL2_Dictionary(c::Cif)\n\nCreate a DDL2_Dictionary from c.\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.DDL2_Dictionary-Tuple{AbstractPath}","page":"API","title":"CrystalInfoFramework.DDL2_Dictionary","text":"DDL2_Dictionary(a::AbstractPath;verbose=false)\n\nCreate a DDL2_Dictionary given filename a. verbose = true will print extra debugging information during reading.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.keys-Tuple{DDL2_Dictionary}","page":"API","title":"Base.keys","text":"keys(d::DDL2_Dictionary)\n\nReturn a list of datanames defined by the dictionary, including any aliases.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{DDL2_Dictionary, Any}","page":"API","title":"Base.getindex","text":"getindex(d::DDL2_Dictionary,k)\n\nd[k] returns the  definition for data name k as a Dict{Symbol,DataFrame} where Symbol is the attribute category (e.g. :item_name).\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.get_categories-Tuple{DDL2_Dictionary}","page":"API","title":"CrystalInfoFramework.get_categories","text":"get_categories(d::DDL2_Dictionary)\n\nList all categories defined in d\n\n\n\n\n\n","category":"method"},{"location":"api/#CrystalInfoFramework.get_default-Tuple{DDL2_Dictionary, Any}","page":"API","title":"CrystalInfoFramework.get_default","text":"get_default(d::DDL2_Dictionary,dataname)\n\nReturn the default value for dataname or missing if none defined. \n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, MIME{Symbol(\"text/cif\")}, DDL2_Dictionary}","page":"API","title":"Base.show","text":"show(io::IO,::MIME\"text/cif\",ddl2_dic::DDL2_Dictionary)\n\nOutput ddl2_dic in CIF format.\n\n\n\n\n\n","category":"method"},{"location":"api/#Data-Sources","page":"API","title":"Data Sources","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Data from arbitrary file formats can be used as long as they return an array of values when provided with a string.","category":"page"},{"location":"api/","page":"API","title":"API","text":"DataSource\nTypedDataSource","category":"page"},{"location":"api/#CrystalInfoFramework.DataContainer.DataSource","page":"API","title":"CrystalInfoFramework.DataContainer.DataSource","text":"A DataSource, when provided with a string referring to a data name from a namespace known to the data source, returns an array of values that are either Native (already Julia types) or Text (requiring interpretation to create Julia types).\n\n\n\n\n\n","category":"type"},{"location":"api/#CrystalInfoFramework.DataContainer.TypedDataSource","page":"API","title":"CrystalInfoFramework.DataContainer.TypedDataSource","text":"TypedDataSource(data,dictionary)\n\nA TypedDataSource is a DataSource that returns items of with the correct type and aliases resolved, as specified in the associated CIF dictionary.\n\n\n\n\n\n","category":"type"},{"location":"#CrystalInfoFramework.jl","page":"Overview","title":"CrystalInfoFramework.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This module implements the International Union of Crystallography's  Crystallographic Information Framework (CIF) standard for CIF file syntax and CIF dictionary construction.","category":"page"},{"location":"tutorial/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"The CIF files used in these examples are provided in the docs directory.","category":"page"},{"location":"tutorial/#Reading-a-CIF-file","page":"Guide","title":"Reading a CIF file","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"To open CIF file demo.cif, and read _cell.length_a from block saly2_all_aniso:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"\nusing CrystalInfoFramework, DataFrames, FilePaths\n\nnc = Cif(p\"demo.cif\")\nmy_block = nc[\"saly2_all_aniso\"]  #could also use first(nc).second\nmy_block[\"_cell.length_a\"]\n\n# output\n\n1-element Array{Union{Missing, Nothing, Dict{String,T}, Array{T,1}, String} where T,1}:\n \"11.520(12)\"","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Note that values are always returned as Array type, with the value for a key value pair being a single-element array. The values in the arrays returned are either String, Missing (CIF ?), Nothing (CIF .) or compound types Dict and Array which are only available for CIF2 syntax files.","category":"page"},{"location":"tutorial/#Loops","page":"Guide","title":"Loops","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Individual columns are returned when the data name is requested, as above.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"get_loop returns a DataFrame object that can be manipulated using the  methods of that package, most obviously, eachrow to iterate over the packets in a loop. To specify the required loop, simply provide any  data name that appears in the loop.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"\nl = get_loop(my_block,\"_atom_site.label\");\n\nfor r in eachrow(l)\n    println(\"$(r[Symbol(\"_atom_site.fract_x\")])\")\nend\n\n# output\n\n.5505(5)\n.4009(5)\n.2501(5)\n.4170(7)\n.3145(7)\n.2789(8)\n.3417(9)\n.4445(9)\n.4797(8)\n.4549(7)","category":"page"},{"location":"tutorial/#Updating-a-CIF-file","page":"Guide","title":"Updating a CIF file","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Single key-value pairs are added in the same way as for a normal dictionary. ","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"my_block[\"_new_item\"] = \"a fine item\"\nmy_block[\"_number_item\"] = 23","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If the dataname belongs to a loop, a two-step process is required to add the values. First the column of values for the new data name is added as above, and then the new dataname can be added to a previously-existing  loop. The following call adds _new_loop_item to the loop containing  _old_item:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"my_block[\"_new_loop_item\"] = [1,2,3,4]\nadd_to_loop!(my_block,\"_old_item\",\"_new_loop_item\")","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"The number of values in the array assigned to _new_loop_item must match the length of the loop it is added to - this is checked.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A completely new loop can be created with create_loop!.  The columns corresponding to the data names provided to create_loop! must  have previously been added to the data block, just like for add_to_loop!.","category":"page"},{"location":"tutorial/#Writing-CIFs","page":"Guide","title":"Writing CIFs","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"To write a CIF, open an IO stream and write the contents of the Cif object as MIME type \"text/cif\":","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"t = open(\"newcif.cif\",\"w\")\nshow(t,MIME(\"text/cif\"),mycif)\nclose(t)","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Note that currently no checks are made for correct construction of data names (e.g. leading underscore and characterset restrictions). This will be checked in the future.","category":"page"},{"location":"tutorial/#Dictionaries-and-DataSources","page":"Guide","title":"Dictionaries and DataSources","text":"","category":"section"},{"location":"tutorial/#Dictionaries","page":"Guide","title":"Dictionaries","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"CIF dictionaries are created by passing the dictionary file name to DDLm_Dictionary or DDL2_Dictionary constructors.  Note that DDL2 dictionaries are published by the Protein Data Bank (wwPDB) and DDLm dictionaries are used by the IUCr.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"d = DDLm_Dictionary(p\"cif_core.dic\")","category":"page"},{"location":"tutorial/#DataSources","page":"Guide","title":"DataSources","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"CIF dictionaries can be used with any DataSource, providing that the datasource recognises the data names defined in the dictionary.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A DataSource is any object returning an array of values when supplied with a string.  A CIF Block conforms to this specification, as does a simple Dict{String,Any}.  DataSources  are defined in submodule CrystalInfoFramework.DataContainer.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A CIF dictionary can be used to obtain data with correct Julia type from a DataSource that uses data names defined in the dictionary by  creating a TypedDataSource:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"using CrystalInfoFramework.DataContainer\nmy_dict = DDLm_Dictionary(p\"../test/cif_core.dic\")\nbd = TypedDataSource(my_block,my_dict)\nbd[\"_cell.length_a\"]\n\n# output\n\n1-element Array{Float64,1}:\n 11.52\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Note that the array elements are now Float64 and that the standard uncertainty has been removed. Future improvements may use Measurements.jl to retain standard uncertainties.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Dictionaries also allow alternative names for a data name to be recognised provided these are noted in the dictionary:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"\nl = bd[\"_cell_length_a\"] #no period in name\n\n# output\n\n1-element Array{Float64,1}:\n 11.52\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"where _cell_length_a is the old form of the data name.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Currently transformations from DataSource values to Julia values assume that the DataSource values are either already of the correct type, or are Strings that can be directly parsed by the Julia parse method.","category":"page"},{"location":"tutorial/#Creating-new-DataSources","page":"Guide","title":"Creating new DataSources","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A file format can be used with CIF dictionaries if:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"It returns an Array of values when provided with a data name defined in the dictionary\nArrays returned for data names from the same CIF category have corresponding values at the same position in the array - that is, they line up correctly if presented as columns in a table.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"At a minimum, the following methods should be defined for the DataSource:  getindex, haskey.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If the above are true of your type, then it is sufficient to define DataSource(::MyType) = IsDataSource() to make it available.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If a DataSource mds can instead be modelled as a collection of DataSources, iterate_blocks should also be defined to iterate over the constituent DataSources. MultiDataSource(mds) will then create a DataSource where values returned for any data names defined in the constituent blocks are automatically aligned. Such MultiDataSource objects can be built to form hierarchies.","category":"page"},{"location":"tutorial/#Types","page":"Guide","title":"Types","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A TypedDataSource consists of a DataSource and a CIF dictionary.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Values returned from a TypedDataSource are transformed to the appropriate Julia type as specified by the dictionary if the underlying  DataSource returns String values formatted in a way that Julia parse can understand.  Otherwise, the DataSource is responsible for returning the appropriate Julia type. Future improvements may add user-defined transformations if that proves necesssary.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A NamespacedTypedDataSource includes data from multiple namespaces. Correctly-typed data for a particular namespace can then be obtained from  the object returned by select_namespace(t::NamespacedTypedDataSource,nspace).","category":"page"},{"location":"tutorial/#Cif-Categories-from-DataSources","page":"Guide","title":"Cif Categories from DataSources","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A CIF category (a 'Relation' in the relational model) can be constructed from a DataSource, a CIF dictionary, and the CIF name of the category:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"as = LoopCategory(\"atom_site\",my_block,my_dict)\n\n# output\n\nCategory atom_site Length 10\n10×7 DataFrame. Omitted printing of 2 columns\n│ Row │ u_iso_or_equiv │ fract_x   │ fract_z   │ adp_type  │ occupancy │\n│     │ Cif Value…?    │ Cif Val…? │ Cif Val…? │ Cif Val…? │ Cif Val…? │\n├─────┼────────────────┼───────────┼───────────┼───────────┼───────────┤\n│ 1   │ .035(3)        │ .5505(5)  │ .1605(11) │ Uani      │ 1.00000   │\n│ 2   │ .033(3)        │ .4009(5)  │ .2290(11) │ Uani      │ 1.00000   │\n│ 3   │ .043(4)        │ .2501(5)  │ .6014(13) │ Uani      │ 1.00000   │\n│ 4   │ .029(4)        │ .4170(7)  │ .4954(15) │ Uani      │ 1.00000   │\n│ 5   │ .031(5)        │ .3145(7)  │ .6425(16) │ Uani      │ 1.00000   │\n│ 6   │ .040(5)        │ .2789(8)  │ .8378(17) │ Uani      │ 1.00000   │\n│ 7   │ .045(6)        │ .3417(9)  │ .8859(18) │ Uani      │ 1.00000   │\n│ 8   │ .045(6)        │ .4445(9)  │ .7425(18) │ Uani      │ 1.00000   │\n│ 9   │ .038(5)        │ .4797(8)  │ .5487(17) │ Uani      │ 1.00000   │\n│ 10  │ .029(4)        │ .4549(7)  │ .2873(16) │ Uani      │ 1.00000   │\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"where a category is either a LoopCategory, with one or more rows, or a SetCategory, which is restricted to a single row. Alternatively, a TypedDataSource can be used, in which case the dictionary used by the TypedDataSource is also used for category construction.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"as = LoopCategory(\"atom_site\",bd)\n\n# output\n\nCategory atom_site Length 10\n10×7 DataFrame. Omitted printing of 2 columns\n│ Row │ u_iso_or_equiv │ fract_x   │ fract_z   │ adp_type  │ occupancy │\n│     │ Cif Value…?    │ Cif Val…? │ Cif Val…? │ Cif Val…? │ Cif Val…? │\n├─────┼────────────────┼───────────┼───────────┼───────────┼───────────┤\n│ 1   │ .035(3)        │ .5505(5)  │ .1605(11) │ Uani      │ 1.00000   │\n│ 2   │ .033(3)        │ .4009(5)  │ .2290(11) │ Uani      │ 1.00000   │\n│ 3   │ .043(4)        │ .2501(5)  │ .6014(13) │ Uani      │ 1.00000   │\n│ 4   │ .029(4)        │ .4170(7)  │ .4954(15) │ Uani      │ 1.00000   │\n│ 5   │ .031(5)        │ .3145(7)  │ .6425(16) │ Uani      │ 1.00000   │\n│ 6   │ .040(5)        │ .2789(8)  │ .8378(17) │ Uani      │ 1.00000   │\n│ 7   │ .045(6)        │ .3417(9)  │ .8859(18) │ Uani      │ 1.00000   │\n│ 8   │ .045(6)        │ .4445(9)  │ .7425(18) │ Uani      │ 1.00000   │\n│ 9   │ .038(5)        │ .4797(8)  │ .5487(17) │ Uani      │ 1.00000   │\n│ 10  │ .029(4)        │ .4549(7)  │ .2873(16) │ Uani      │ 1.00000   │\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"getindex for CIF categories uses the indexing value as the key value for looking up a row in the category:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"one_row = as[\"o1\"]\none_row.fract_x\n\n# output\n\n\".5505(5)\"\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If a category key consists multiple data names, a Dict{Symbol,V} should be provided as the indexing value, where Symbol is the object_id of the particular data name forming part of the key and V is the type of the values.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A category can be iterated over as usual, with the value of each dataname for each row available as a property:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"for one_row in as\n    println(\"$(one_row.label) $(one_row.fract_x) $(one_row.fract_y) $(one_row.fract_z)\")\nend\n\n# output\n\no1 .5505(5) .6374(5) .1605(11)\no2 .4009(5) .5162(5) .2290(11)\no3 .2501(5) .5707(5) .6014(13)\nc1 .4170(7) .6930(8) .4954(15)\nc2 .3145(7) .6704(8) .6425(16)\nc3 .2789(8) .7488(8) .8378(17)\nc4 .3417(9) .8529(8) .8859(18)\nc5 .4445(9) .8778(9) .7425(18)\nc6 .4797(8) .7975(8) .5487(17)\nc7 .4549(7) .6092(7) .2873(16)\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If you prefer the DataFrame tools for working with tables, DataFrame(c::CifCategory) creates a DataFrame:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"DataFrame(as)\n\n# output\n\n10×7 DataFrame. Omitted printing of 2 columns\n│ Row │ u_iso_or_equiv │ fract_x   │ fract_z   │ adp_type  │ occupancy │\n│     │ Cif Value…?    │ Cif Val…? │ Cif Val…? │ Cif Val…? │ Cif Val…? │\n├─────┼────────────────┼───────────┼───────────┼───────────┼───────────┤\n│ 1   │ .035(3)        │ .5505(5)  │ .1605(11) │ Uani      │ 1.00000   │\n│ 2   │ .033(3)        │ .4009(5)  │ .2290(11) │ Uani      │ 1.00000   │\n│ 3   │ .043(4)        │ .2501(5)  │ .6014(13) │ Uani      │ 1.00000   │\n│ 4   │ .029(4)        │ .4170(7)  │ .4954(15) │ Uani      │ 1.00000   │\n│ 5   │ .031(5)        │ .3145(7)  │ .6425(16) │ Uani      │ 1.00000   │\n│ 6   │ .040(5)        │ .2789(8)  │ .8378(17) │ Uani      │ 1.00000   │\n│ 7   │ .045(6)        │ .3417(9)  │ .8859(18) │ Uani      │ 1.00000   │\n│ 8   │ .045(6)        │ .4445(9)  │ .7425(18) │ Uani      │ 1.00000   │\n│ 9   │ .038(5)        │ .4797(8)  │ .5487(17) │ Uani      │ 1.00000   │\n│ 10  │ .029(4)        │ .4549(7)  │ .2873(16) │ Uani      │ 1.00000   │\n","category":"page"}]
}
