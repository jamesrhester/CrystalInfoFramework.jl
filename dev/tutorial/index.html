<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Guide · CrystalInfoFramework documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CrystalInfoFramework documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>Guide</a><ul class="internal"><li><a class="tocitem" href="#Reading-a-CIF-file"><span>Reading a CIF file</span></a></li><li><a class="tocitem" href="#Updating-a-CIF-file"><span>Updating a CIF file</span></a></li><li><a class="tocitem" href="#Writing-CIFs"><span>Writing CIFs</span></a></li><li><a class="tocitem" href="#Dictionaries-and-DataSources"><span>Dictionaries and DataSources</span></a></li><li><a class="tocitem" href="#Cif-Categories-from-DataSources"><span>Cif Categories from DataSources</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jamesrhester/CrystalInfoFramework.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Guide"><a class="docs-heading-anchor" href="#Guide">Guide</a><a id="Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Guide" title="Permalink"></a></h1><p>The CIF files used in these examples are provided in the <code>docs</code> directory.</p><h2 id="Reading-a-CIF-file"><a class="docs-heading-anchor" href="#Reading-a-CIF-file">Reading a CIF file</a><a id="Reading-a-CIF-file-1"></a><a class="docs-heading-anchor-permalink" href="#Reading-a-CIF-file" title="Permalink"></a></h2><p>To open CIF file <code>demo.cif</code>, and read <code>_cell.length_a</code> from block <code>saly2_all_aniso</code>:</p><pre><code class="language-julia">
using CrystalInfoFramework, DataFrames, FilePaths

nc = Cif(p&quot;demo.cif&quot;)
my_block = nc[&quot;saly2_all_aniso&quot;]  #could also use first(nc).second
my_block[&quot;_cell.length_a&quot;]

# output

1-element Array{Union{Missing, Nothing, Dict{String,T}, Array{T,1}, String} where T,1}:
 &quot;11.520(12)&quot;</code></pre><p>Note that values are <em>always</em> returned as <code>Array</code> type, with the value for a key value pair being a single-element array. The values in the arrays returned are either <code>String</code>, <code>Missing</code> (CIF <code>?</code>), <code>Nothing</code> (CIF <code>.</code>) or compound types <code>Dict</code> and <code>Array</code> which are only available for CIF2 syntax files.</p><p>Option <code>native=false</code> to <code>Cif</code> will use the <code>cif_api</code> C parser instead of the Julia parser. The <code>cif_api</code> parser is faster and more memory-efficient for scripting use, whereas the native parser is faster if compilation time is less of a consideration (e.g. multiple files are being read in). The <code>cif_api</code> parser is not currently available on Windows systems.</p><h3 id="Loops"><a class="docs-heading-anchor" href="#Loops">Loops</a><a id="Loops-1"></a><a class="docs-heading-anchor-permalink" href="#Loops" title="Permalink"></a></h3><p>Individual columns are returned when the data name is requested, as above.</p><p><a href="../api/#CrystalInfoFramework.get_loop"><code>get_loop</code></a> returns a <code>DataFrame</code> object that can be manipulated using the  methods of that package, most obviously, <code>eachrow</code> to iterate over the packets in a loop. To specify the required loop, simply provide any  data name that appears in the loop.</p><pre><code class="language-julia">
l = get_loop(my_block,&quot;_atom_site.label&quot;);

for r in eachrow(l)
    println(&quot;$(r[Symbol(&quot;_atom_site.fract_x&quot;)])&quot;)
end

# output

.5505(5)
.4009(5)
.2501(5)
.4170(7)
.3145(7)
.2789(8)
.3417(9)
.4445(9)
.4797(8)
.4549(7)</code></pre><h2 id="Updating-a-CIF-file"><a class="docs-heading-anchor" href="#Updating-a-CIF-file">Updating a CIF file</a><a id="Updating-a-CIF-file-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-a-CIF-file" title="Permalink"></a></h2><p>Single key-value pairs are added in the same way as for a normal dictionary. </p><pre><code class="language-julia">my_block[&quot;_new_item&quot;] = &quot;a fine item&quot;
my_block[&quot;_number_item&quot;] = 23</code></pre><p>If the dataname belongs to a loop, a two-step process is required to add the values. First the column of values for the new data name is added as above, and then the new dataname can be added to a previously-existing  loop. The following call adds <code>_new_loop_item</code> to the loop containing  <code>_old_item</code>:</p><pre><code class="language-julia">my_block[&quot;_new_loop_item&quot;] = [1,2,3,4]
add_to_loop!(my_block,&quot;_old_item&quot;,&quot;_new_loop_item&quot;)</code></pre><p>The number of values in the array assigned to <code>_new_loop_item</code> must match the length of the loop it is added to - this is checked.</p><p>A completely new loop can be created with <a href="../api/#CrystalInfoFramework.create_loop!"><code>create_loop!</code></a>.  The columns corresponding to the data names provided to <code>create_loop!</code> must  have previously been added to the data block, just like for <a href="../api/#CrystalInfoFramework.add_to_loop!"><code>add_to_loop!</code></a>.</p><h2 id="Writing-CIFs"><a class="docs-heading-anchor" href="#Writing-CIFs">Writing CIFs</a><a id="Writing-CIFs-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-CIFs" title="Permalink"></a></h2><p>To write a CIF, open an IO stream and write the contents of the <code>Cif</code> object as MIME type &quot;text/cif&quot;:</p><pre><code class="language-julia">t = open(&quot;newcif.cif&quot;,&quot;w&quot;)
show(t,MIME(&quot;text/cif&quot;),mycif)
close(t)</code></pre><p>Note that currently no checks are made for correct construction of data names (e.g. leading underscore and characterset restrictions). This will be checked in the future.</p><h2 id="Dictionaries-and-DataSources"><a class="docs-heading-anchor" href="#Dictionaries-and-DataSources">Dictionaries and DataSources</a><a id="Dictionaries-and-DataSources-1"></a><a class="docs-heading-anchor-permalink" href="#Dictionaries-and-DataSources" title="Permalink"></a></h2><h3 id="Dictionaries"><a class="docs-heading-anchor" href="#Dictionaries">Dictionaries</a><a id="Dictionaries-1"></a><a class="docs-heading-anchor-permalink" href="#Dictionaries" title="Permalink"></a></h3><p>CIF dictionaries are created by passing the dictionary file name to <a href="../api/#CrystalInfoFramework.DDLm_Dictionary"><code>DDLm_Dictionary</code></a> or <a href="../api/#CrystalInfoFramework.DDL2_Dictionary"><code>DDL2_Dictionary</code></a> constructors.  Note that DDL2 dictionaries are published by the Protein Data Bank (wwPDB) and DDLm dictionaries are used by the IUCr.</p><pre><code class="language-julia">d = DDLm_Dictionary(p&quot;cif_core.dic&quot;)</code></pre><h3 id="DataSources"><a class="docs-heading-anchor" href="#DataSources">DataSources</a><a id="DataSources-1"></a><a class="docs-heading-anchor-permalink" href="#DataSources" title="Permalink"></a></h3><p>CIF dictionaries can be used with any <code>DataSource</code>, providing that the datasource recognises the data names defined in the dictionary.</p><p>A <code>DataSource</code> is any object returning an array of values when supplied with a string.  A CIF <code>Block</code> conforms to this specification, as does a simple <code>Dict{String,Any}</code>.  <code>DataSource</code>s  are defined in submodule <code>CrystalInfoFramework.DataContainer</code>.</p><p>A CIF dictionary can be used to obtain data with correct Julia type from a <code>DataSource</code> that uses data names defined in the dictionary by  creating a <a href="../api/#CrystalInfoFramework.DataContainer.TypedDataSource"><code>TypedDataSource</code></a>:</p><pre><code class="language-julia">using CrystalInfoFramework.DataContainer
my_dict = DDLm_Dictionary(p&quot;../test/cif_core.dic&quot;)
bd = TypedDataSource(my_block,my_dict)
bd[&quot;_cell.length_a&quot;]

# output

1-element Array{Float64,1}:
 11.52
</code></pre><p>Note that the array elements are now <code>Float64</code> and that the standard uncertainty has been removed. Future improvements may use <code>Measurements.jl</code> to retain standard uncertainties.</p><p>Dictionaries also allow alternative names for a data name to be recognised provided these are noted in the dictionary:</p><pre><code class="language-julia">
l = bd[&quot;_cell_length_a&quot;] #no period in name

# output

1-element Array{Float64,1}:
 11.52
</code></pre><p>where <code>_cell_length_a</code> is the old form of the data name.</p><p>Currently transformations from <code>DataSource</code> values to Julia values assume that the <code>DataSource</code> values are either already of the correct type, or are <code>String</code>s that can be directly parsed by the Julia <code>parse</code> method.</p><h4 id="Creating-new-DataSources"><a class="docs-heading-anchor" href="#Creating-new-DataSources">Creating new DataSources</a><a id="Creating-new-DataSources-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-new-DataSources" title="Permalink"></a></h4><p>A file format can be used with CIF dictionaries if:</p><ol><li>It returns an <code>Array</code> of values when provided with a data name defined in the dictionary</li><li><code>Array</code>s returned for data names from the same CIF category have corresponding values at the same position in the array - that is, they line up correctly if presented as columns in a table.</li></ol><p>At a minimum, the following methods should be defined for the <code>DataSource</code>:  <code>getindex</code>, <code>haskey</code>.</p><p>If the above are true of your type, then it is sufficient to define <code>DataSource(::MyType) = IsDataSource()</code> to make it available.</p><p>If a <code>DataSource</code> <code>mds</code> can instead be modelled as a collection of <code>DataSource</code>s, <code>iterate_blocks</code> should also be defined to iterate over the constituent <code>DataSource</code>s. <code>MultiDataSource(mds)</code> will then create a <code>DataSource</code> where values returned for any data names defined in the constituent blocks are automatically aligned. Such <code>MultiDataSource</code> objects can be built to form hierarchies.</p><h4 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h4><p>A <code>TypedDataSource</code> consists of a <code>DataSource</code> and a CIF dictionary.</p><p>Values returned from a <code>TypedDataSource</code> are transformed to the appropriate Julia type as specified by the dictionary <em>if</em> the underlying  <code>DataSource</code> returns <code>String</code> values formatted in a way that Julia <code>parse</code> can understand.  Otherwise, the <code>DataSource</code> is responsible for returning the appropriate Julia type. Future improvements may add user-defined transformations if that proves necesssary.</p><p>A <code>NamespacedTypedDataSource</code> includes data from multiple namespaces. Correctly-typed data for a particular namespace can then be obtained from  the object returned by <code>select_namespace(t::NamespacedTypedDataSource,nspace)</code>.</p><h2 id="Cif-Categories-from-DataSources"><a class="docs-heading-anchor" href="#Cif-Categories-from-DataSources">Cif Categories from DataSources</a><a id="Cif-Categories-from-DataSources-1"></a><a class="docs-heading-anchor-permalink" href="#Cif-Categories-from-DataSources" title="Permalink"></a></h2><p>A CIF category (a &#39;Relation&#39; in the relational model) can be constructed from a <code>DataSource</code>, a CIF dictionary, and the CIF name of the category:</p><pre><code class="language-julia">as = LoopCategory(&quot;atom_site&quot;,my_block,my_dict)

# output

Category atom_site Length 10
10×7 DataFrame. Omitted printing of 2 columns
│ Row │ u_iso_or_equiv │ fract_x   │ fract_z   │ adp_type  │ occupancy │
│     │ Cif Value…?    │ Cif Val…? │ Cif Val…? │ Cif Val…? │ Cif Val…? │
├─────┼────────────────┼───────────┼───────────┼───────────┼───────────┤
│ 1   │ .035(3)        │ .5505(5)  │ .1605(11) │ Uani      │ 1.00000   │
│ 2   │ .033(3)        │ .4009(5)  │ .2290(11) │ Uani      │ 1.00000   │
│ 3   │ .043(4)        │ .2501(5)  │ .6014(13) │ Uani      │ 1.00000   │
│ 4   │ .029(4)        │ .4170(7)  │ .4954(15) │ Uani      │ 1.00000   │
│ 5   │ .031(5)        │ .3145(7)  │ .6425(16) │ Uani      │ 1.00000   │
│ 6   │ .040(5)        │ .2789(8)  │ .8378(17) │ Uani      │ 1.00000   │
│ 7   │ .045(6)        │ .3417(9)  │ .8859(18) │ Uani      │ 1.00000   │
│ 8   │ .045(6)        │ .4445(9)  │ .7425(18) │ Uani      │ 1.00000   │
│ 9   │ .038(5)        │ .4797(8)  │ .5487(17) │ Uani      │ 1.00000   │
│ 10  │ .029(4)        │ .4549(7)  │ .2873(16) │ Uani      │ 1.00000   │
</code></pre><p>where a category is either a <code>LoopCategory</code>, with one or more rows, or a <code>SetCategory</code>, which is restricted to a single row. Alternatively, a <code>TypedDataSource</code> can be used, in which case the dictionary used by the <code>TypedDataSource</code> is also used for category construction.</p><pre><code class="language-julia">as = LoopCategory(&quot;atom_site&quot;,bd)

# output

Category atom_site Length 10
10×7 DataFrame. Omitted printing of 2 columns
│ Row │ u_iso_or_equiv │ fract_x   │ fract_z   │ adp_type  │ occupancy │
│     │ Cif Value…?    │ Cif Val…? │ Cif Val…? │ Cif Val…? │ Cif Val…? │
├─────┼────────────────┼───────────┼───────────┼───────────┼───────────┤
│ 1   │ .035(3)        │ .5505(5)  │ .1605(11) │ Uani      │ 1.00000   │
│ 2   │ .033(3)        │ .4009(5)  │ .2290(11) │ Uani      │ 1.00000   │
│ 3   │ .043(4)        │ .2501(5)  │ .6014(13) │ Uani      │ 1.00000   │
│ 4   │ .029(4)        │ .4170(7)  │ .4954(15) │ Uani      │ 1.00000   │
│ 5   │ .031(5)        │ .3145(7)  │ .6425(16) │ Uani      │ 1.00000   │
│ 6   │ .040(5)        │ .2789(8)  │ .8378(17) │ Uani      │ 1.00000   │
│ 7   │ .045(6)        │ .3417(9)  │ .8859(18) │ Uani      │ 1.00000   │
│ 8   │ .045(6)        │ .4445(9)  │ .7425(18) │ Uani      │ 1.00000   │
│ 9   │ .038(5)        │ .4797(8)  │ .5487(17) │ Uani      │ 1.00000   │
│ 10  │ .029(4)        │ .4549(7)  │ .2873(16) │ Uani      │ 1.00000   │
</code></pre><p><code>getindex</code> for CIF categories uses the indexing value as the <em>key value</em> for looking up a row in the category:</p><pre><code class="language-julia">one_row = as[&quot;o1&quot;]
one_row.fract_x

# output

&quot;.5505(5)&quot;
</code></pre><p>If a category key consists multiple data names, a <code>Dict{Symbol,V}</code> should be provided as the indexing value, where <code>Symbol</code> is the <code>object_id</code> of the particular data name forming part of the key and <code>V</code> is the type of the values.</p><p>A category can be iterated over as usual, with the value of each dataname for each row available as a property:</p><pre><code class="language-julia">for one_row in as
    println(&quot;$(one_row.label) $(one_row.fract_x) $(one_row.fract_y) $(one_row.fract_z)&quot;)
end

# output

o1 .5505(5) .6374(5) .1605(11)
o2 .4009(5) .5162(5) .2290(11)
o3 .2501(5) .5707(5) .6014(13)
c1 .4170(7) .6930(8) .4954(15)
c2 .3145(7) .6704(8) .6425(16)
c3 .2789(8) .7488(8) .8378(17)
c4 .3417(9) .8529(8) .8859(18)
c5 .4445(9) .8778(9) .7425(18)
c6 .4797(8) .7975(8) .5487(17)
c7 .4549(7) .6092(7) .2873(16)
</code></pre><p>If you prefer the <code>DataFrame</code> tools for working with tables, <code>DataFrame(c::CifCategory)</code> creates a <code>DataFrame</code>:</p><pre><code class="language-julia">DataFrame(as)

# output

10×7 DataFrame. Omitted printing of 2 columns
│ Row │ u_iso_or_equiv │ fract_x   │ fract_z   │ adp_type  │ occupancy │
│     │ Cif Value…?    │ Cif Val…? │ Cif Val…? │ Cif Val…? │ Cif Val…? │
├─────┼────────────────┼───────────┼───────────┼───────────┼───────────┤
│ 1   │ .035(3)        │ .5505(5)  │ .1605(11) │ Uani      │ 1.00000   │
│ 2   │ .033(3)        │ .4009(5)  │ .2290(11) │ Uani      │ 1.00000   │
│ 3   │ .043(4)        │ .2501(5)  │ .6014(13) │ Uani      │ 1.00000   │
│ 4   │ .029(4)        │ .4170(7)  │ .4954(15) │ Uani      │ 1.00000   │
│ 5   │ .031(5)        │ .3145(7)  │ .6425(16) │ Uani      │ 1.00000   │
│ 6   │ .040(5)        │ .2789(8)  │ .8378(17) │ Uani      │ 1.00000   │
│ 7   │ .045(6)        │ .3417(9)  │ .8859(18) │ Uani      │ 1.00000   │
│ 8   │ .045(6)        │ .4445(9)  │ .7425(18) │ Uani      │ 1.00000   │
│ 9   │ .038(5)        │ .4797(8)  │ .5487(17) │ Uani      │ 1.00000   │
│ 10  │ .029(4)        │ .4549(7)  │ .2873(16) │ Uani      │ 1.00000   │
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 15 August 2022 08:10">Monday 15 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
